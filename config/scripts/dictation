#!/usr/bin/env python3
"""
Push-to-talk dictation using faster-whisper
Completely offline speech recognition
"""

import sys
import time
import tempfile
import subprocess
import signal
import os
from pathlib import Path

def notify(title, message, urgency="normal", timeout=2000, replace_id=None):
    """Send desktop notification with auto-dismiss"""
    try:
        cmd = [
            'notify-send', 
            '--urgency', urgency,
            '--expire-time', str(timeout),
            '--app-name', 'Dictation'
        ]
        
        # Use replace-id to update existing notifications
        if replace_id:
            cmd.extend(['--replace-id', str(replace_id)])
            
        cmd.extend([title, message])
        subprocess.run(cmd, check=False)
    except:
        pass

def dismiss_recording_notification():
    """Dismiss the persistent recording notification"""
    try:
        # Send an empty notification with the same ID to close it
        subprocess.run([
            'notify-send',
            '--replace-id', '1',
            '--expire-time', '1',
            '--app-name', 'Dictation',
            '', ''
        ], check=False)
    except:
        pass

# Global variables for cleanup
recording_process = None
temp_file = None

def cleanup():
    """Clean up recording process and temp files"""
    global recording_process, temp_file
    
    # Remove indicator file
    try:
        os.unlink('/tmp/dictation_active')
    except:
        pass
    
    if recording_process and recording_process.poll() is None:
        recording_process.terminate()
        try:
            recording_process.wait(timeout=1)
        except subprocess.TimeoutExpired:
            recording_process.kill()
    
    if temp_file and os.path.exists(temp_file):
        os.unlink(temp_file)

def signal_handler(signum, frame):
    """Handle interrupt signals"""
    global recording_process
    
    # Send SIGINT to ffmpeg to stop recording gracefully
    if recording_process and recording_process.poll() is None:
        try:
            recording_process.send_signal(signal.SIGINT)
            recording_process.wait(timeout=1)
        except subprocess.TimeoutExpired:
            recording_process.kill()
        except:
            pass
    
    sys.exit(0)

def start_recording():
    """Start audio recording"""
    global recording_process, temp_file
    
    # Create temporary WAV file with a more predictable name
    temp_file = '/tmp/dictation_recording.wav'
    
    # Create lock file to track recording state
    lock_file = '/tmp/dictation_recording.lock'
    with open(lock_file, 'w') as f:
        f.write(f"{os.getpid()}\n{temp_file}")
    
    # Start recording with ffmpeg (uses PipeWire/PulseAudio)
    cmd = [
        'ffmpeg', '-y',
        '-f', 'pulse',  # Use PulseAudio/PipeWire
        '-i', 'default',  # Default input device
        '-ac', '1',  # Mono audio
        '-ar', '16000',  # 16kHz sample rate (optimal for Whisper)
        '-acodec', 'pcm_s16le',  # 16-bit PCM
        temp_file
    ]
    
    try:
        # Suppress ffmpeg output
        recording_process = subprocess.Popen(
            cmd, 
            stdout=subprocess.DEVNULL, 
            stderr=subprocess.DEVNULL
        )
        # Create visual indicator file for other tools to detect
        with open('/tmp/dictation_active', 'w') as f:
            f.write('recording')
        return True
    except FileNotFoundError:
        notify("‚ùå", "ffmpeg not found", "critical", timeout=4000)
        return False
    except Exception as e:
        notify("‚ùå", f"Recording failed: {e}", "critical", timeout=4000)
        return False

def stop_recording_and_transcribe():
    """Stop recording and transcribe audio"""
    global recording_process, temp_file
    
    # Check if audio file was created and has content
    if not temp_file or not os.path.exists(temp_file) or os.path.getsize(temp_file) == 0:
        notify("‚ùå", "No audio recorded", timeout=3000)
        cleanup()
        return
    
    # Remove indicator file
    try:
        os.unlink('/tmp/dictation_active')
    except:
        pass
    
    try:
        # Import here to avoid startup delay
        import whisper
        
        # Use tiny model for maximum speed (39MB, ~4x faster than base)
        model = whisper.load_model("tiny")
        
        # Transcribe with speed optimizations
        result = model.transcribe(temp_file, fp16=False, language="en")
        
        # Get transcribed text
        final_text = result["text"].strip()
        
        if final_text:
            # Type the text using wtype (Wayland)
            try:
                subprocess.run(['wtype', final_text], check=True)
                # Only show notification on success - show what was typed
                notify("üìù", final_text, timeout=3000)
            except subprocess.CalledProcessError:
                notify("‚ùå", f"Failed to type: {final_text}", timeout=5000)
            except FileNotFoundError:
                notify("‚ùå", f"wtype missing: {final_text}", timeout=5000)
            
    except ImportError:
        notify("‚ùå", "whisper not installed", "critical", timeout=5000)
    except Exception as e:
        notify("‚ùå", f"Error: {e}", "critical", timeout=4000)
    finally:
        cleanup()

def main():
    """Main entry point"""
    # Set up signal handlers
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    
    if len(sys.argv) != 2:
        print("Usage: dictation toggle")
        sys.exit(1)
    
    command = sys.argv[1]
    
    if command == "toggle":
        # Check if already recording using lock file
        global temp_file  # Declare global here
        lock_file = '/tmp/dictation_recording.lock'
        if os.path.exists(lock_file):
            # Already recording, stop it
            try:
                with open(lock_file, 'r') as f:
                    lines = f.read().strip().split('\n')
                    pid = int(lines[0])
                    audio_file = lines[1]
                
                # Kill the recording process gracefully
                try:
                    os.kill(pid, signal.SIGINT)
                    
                    # Poll for file to be ready (max 0.5s)
                    for _ in range(25):  # 25 * 0.02s = 0.5s max
                        if os.path.exists(audio_file) and os.path.getsize(audio_file) > 1000:
                            break
                        time.sleep(0.02)
                except:
                    pass
                
                # Set temp_file and transcribe the recording
                temp_file = audio_file
                
                stop_recording_and_transcribe()
                
                # Remove lock file after transcription
                try:
                    os.unlink(lock_file)
                except:
                    pass
                
            except Exception as e:
                notify("‚ùå Error", f"Failed to stop recording: {e}", "critical")
                # Clean up lock file anyway
                try:
                    os.unlink(lock_file)
                except:
                    pass
        else:
            # Not recording, start it
            if start_recording():
                try:
                    while True:
                        time.sleep(0.1)
                except KeyboardInterrupt:
                    pass
    else:
        print("Usage: dictation toggle")
        sys.exit(1)

if __name__ == "__main__":
    main()
