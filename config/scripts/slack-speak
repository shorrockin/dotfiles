#!/usr/bin/env python3
"""Read Slack messages from a specific user aloud using macOS say."""

import argparse
import html
import json
import re
import subprocess
import sys
import time
import urllib.error
import urllib.parse
import urllib.request


def get_tokens(workspace=None):
    """Extract Slack tokens from the desktop app via slacktokens."""
    try:
        import slacktokens
    except ImportError:
        print("Error: slacktokens not installed. Run: pip install slacktokens", file=sys.stderr)
        sys.exit(1)

    tokens = slacktokens.get_tokens_and_cookie()
    if not tokens:
        print("Error: No Slack tokens found. Is the Slack desktop app installed?", file=sys.stderr)
        print("Note: Slack may need to be closed on first run (LevelDB limitation).", file=sys.stderr)
        sys.exit(1)

    if workspace:
        for t in tokens:
            if workspace in t.get("team_name", "") or workspace in t.get("team_url", ""):
                return t["token"], t["cookie"]
        print(f"Error: No token found for workspace '{workspace}'.", file=sys.stderr)
        print("Available workspaces:", file=sys.stderr)
        for t in tokens:
            print(f"  - {t.get('team_name', 'unknown')} ({t.get('team_url', '')})", file=sys.stderr)
        sys.exit(1)

    return tokens[0]["token"], tokens[0]["cookie"]


def clean_message(text):
    """Strip Slack markup for spoken output."""
    # <@U123ABC> user mentions → remove
    text = re.sub(r"<@[A-Z0-9]+>", "", text)
    # <http://url|label> → "label"
    text = re.sub(r"<(https?://[^|>]+)\|([^>]+)>", r"\2", text)
    # <http://url> → "a link"
    text = re.sub(r"<https?://[^>]+>", "a link", text)
    # :emoji_name: → remove
    text = re.sub(r":[a-z0-9_+-]+:", "", text)
    # Unescape HTML entities
    text = html.unescape(text)
    # Collapse whitespace
    text = re.sub(r"  +", " ", text).strip()
    return text


def slack_api(method, token, cookie, params=None):
    """Call a Slack API method and return the JSON response."""
    url = f"https://slack.com/api/{method}"
    if params:
        url += "?" + urllib.parse.urlencode(params)

    req = urllib.request.Request(url)
    req.add_header("Authorization", f"Bearer {token}")
    req.add_header("Cookie", f"d={cookie}")

    try:
        with urllib.request.urlopen(req, timeout=15) as resp:
            data = json.loads(resp.read())
    except urllib.error.URLError as e:
        print(f"API error: {e}", file=sys.stderr)
        return None

    if not data.get("ok"):
        print(f"Slack API error: {data.get('error', 'unknown')}", file=sys.stderr)
        return None

    return data


def speak(text, voice=None):
    """Speak text using macOS say command."""
    cmd = ["say"]
    if voice:
        cmd += ["-v", voice]
    cmd.append(text)
    subprocess.run(cmd)


HELP_EPILOG = """\
setup:
  1. Install the slacktokens package:
       pip install slacktokens

  2. Close the Slack desktop app (required on first run for LevelDB access).
     Your macOS keychain password may be prompted for cookie decryption.

  3. Find the target user ID and channel ID in Slack:
       - User ID:    click a user's profile -> "..." menu -> "Copy member ID"
       - Channel ID: right-click a channel -> "View channel details" ->
                     scroll to bottom, or copy from the URL bar (C0XXXXXXX)

  4. Run the script:
       slack-speak --user-id U0XXXXXXX --channel C0XXXXXXX

examples:
  slack-speak --user-id U0XXXXXXX --channel C0XXXXXXX
  slack-speak --user-id U0XXXXXXX --channel C0XXXXXXX --voice Samantha --interval 5
  slack-speak --user-id U0XXXXXXX --channel C0XXXXXXX --workspace mycompany
  slack-speak --user-id U0XXXXXXX --channel C0XXXXXXX --dry-run
"""


def main():
    parser = argparse.ArgumentParser(
        description=__doc__,
        epilog=HELP_EPILOG,
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    parser.add_argument("--user-id", required=True, help="Slack user ID to monitor (e.g. U0XXXXXXX)")
    parser.add_argument("--channel", required=True, help="Slack channel ID to monitor (e.g. C0XXXXXXX)")
    parser.add_argument("--workspace", help="Slack workspace name/url to select token for (uses first found if omitted)")
    parser.add_argument("--voice", help="macOS say voice (e.g. Samantha, Daniel, Zarvox)")
    parser.add_argument("--dry-run", action="store_true", help="Print messages to stdout instead of speaking")
    parser.add_argument("--interval", type=int, default=10, help="Polling interval in seconds (default: 10)")
    args = parser.parse_args()

    if args.dry_run:
        token, cookie = "dry-run", "dry-run"
        print("Dry-run mode: skipping token extraction, will print instead of speaking.")
    else:
        print("Extracting Slack tokens...")
        token, cookie = get_tokens(args.workspace)
        print("Tokens acquired.")

    # Start polling from now
    last_ts = str(time.time())
    print(f"Monitoring channel {args.channel} for messages from {args.user_id}...")
    print(f"Polling every {args.interval}s. Press Ctrl+C to stop.\n")

    try:
        while True:
            if not args.dry_run:
                data = slack_api("conversations.history", token, cookie, {
                    "channel": args.channel,
                    "oldest": last_ts,
                    "limit": 50,
                })

                if data and data.get("messages"):
                    # Messages come newest-first, reverse to process chronologically
                    for msg in reversed(data["messages"]):
                        if msg.get("user") == args.user_id and msg.get("type") == "message":
                            raw = msg.get("text", "")
                            cleaned = clean_message(raw)
                            if cleaned:
                                print(f"[{msg['user']}] {cleaned}")
                                speak(cleaned, args.voice)
                            last_ts = msg["ts"]

            time.sleep(args.interval)
    except KeyboardInterrupt:
        print("\nStopped.")


if __name__ == "__main__":
    main()
