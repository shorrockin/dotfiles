#!/usr/bin/env bash

# History file for tracking recency
HISTORY_FILE="$HOME/.cache/tmux-sessionizer-history"
CONFIG_FILE="$HOME/.tmux-sessionizer.conf"

# Ensure cache directory exists
mkdir -p "$(dirname "$HISTORY_FILE")"

# Show help message
show_help() {
    cat << 'EOF'
tmux-sessionizer - Fast tmux session switcher with config-driven project management

USAGE:
    tmux-sessionizer [OPTIONS] [SESSION_NAME | DIRECTORY]

DESCRIPTION:
    Interactive fuzzy finder for switching between tmux sessions and configured projects.
    Uses a config file to map session names to directories for fast, predictable access.

OPTIONS:
    help, --help, -h    Show this help message

ARGUMENTS:
    SESSION_NAME        Optional: Create/switch to a session with this name in the current directory
    DIRECTORY           Optional: Create/switch to a session for this directory (uses basename as name)

CONFIGURATION:
    Config file: ~/.tmux-sessionizer.conf
    Format: session_name=/path/to/directory

    Config entries are displayed as: session_name (directory)
    Active tmux sessions are marked with: ● session_name

    Example:
        # Comment lines start with #
        dotfiles=/Users/username/dotfiles
        work-project=/Users/username/work/main-app
        personal=/Users/username/projects/blog

    Each line maps a session name (left of =) to a directory path (right of =).
    Session names can be anything you want - they don't need to match directory names.

    Notes:
    • Do not use ● (bullet) in session names - it's reserved for marking active sessions
    • Config entries for already-active sessions won't be shown (avoids duplicates)

FEATURES:
    • Configuration-driven: Only shows projects you explicitly configure
    • History-based sorting: Most recently used sessions appear first
    • Session list: Shows existing tmux sessions (marked with ●) alongside configured projects
    • Fast startup: No file system scanning or preview overhead, near-instant (10-30ms)
    • Interactive fuzzy search: Quickly find and switch between sessions

KEYBINDINGS (in fzf):
    Ctrl+J/K or ↑↓     Navigate up/down
    Enter              Select and switch to session
    Ctrl+C or Esc      Cancel selection

EXAMPLES:
    # Interactive selection
    tmux-sessionizer

    # Create/switch to session by name (uses current directory)
    tmux-sessionizer newsession

    # Create/switch to session by directory path (uses basename as session name)
    tmux-sessionizer ~/projects/myapp

    # Generate initial config from a directory
    for dir in ~/work/*; do
        [[ -d "$dir" ]] && echo "$(basename "$dir")=$dir"
    done > ~/.tmux-sessionizer.conf

    # Add current directory to config
    echo "$(basename "$PWD")=$PWD" >> ~/.tmux-sessionizer.conf

FILES:
    ~/.tmux-sessionizer.conf            Configuration file (session_name=directory pairs)
    ~/.cache/tmux-sessionizer-history   History file (50 most recent selections)

SEE ALSO:
    tmux(1), fzf(1)
EOF
}

# Read configuration file and output session_name:directory pairs
read_config() {
    if [[ ! -f "$CONFIG_FILE" ]]; then
        echo "Warning: Config file $CONFIG_FILE not found. Create it with format: session_name=/path/to/directory" >&2
        return
    fi

    while IFS='=' read -r session_name directory; do
        # Skip empty lines and comments
        [[ -z "$session_name" || "$session_name" =~ ^[[:space:]]*# ]] && continue

        # Trim whitespace (pure bash, no subprocess)
        session_name="${session_name#"${session_name%%[![:space:]]*}"}"
        session_name="${session_name%"${session_name##*[![:space:]]}"}"
        directory="${directory#"${directory%%[![:space:]]*}"}"
        directory="${directory%"${directory##*[![:space:]]}"}"

        # Skip empty after trim
        [[ -z "$session_name" || -z "$directory" ]] && continue

        echo "${session_name}:${directory}"
    done < "$CONFIG_FILE"
}

# Function to update history with the selected item
update_history() {
    local item="$1"
    local temp_file="${HISTORY_FILE}.tmp.$$"

    # Single pass: add new item to front, remove duplicates, truncate to 50
    {
        echo "$item"
        if [[ -f "$HISTORY_FILE" ]]; then
            grep -vF "$item" "$HISTORY_FILE" 2>/dev/null | head -49
        fi
    } > "$temp_file"

    mv "$temp_file" "$HISTORY_FILE"
}

# Function to get items sorted by recency
get_sorted_items() {
    local all_items="$1"

    if [[ ! -f "$HISTORY_FILE" ]]; then
        echo "$all_items"
        return
    fi

    # Build associative array for O(1) lookups
    declare -A all_map
    while IFS= read -r item; do
        [[ -n "$item" ]] && all_map["$item"]=1
    done <<< "$all_items"

    # Read history into array and iterate in reverse (newest to oldest)
    mapfile -t history_items < "$HISTORY_FILE"
    for ((i=${#history_items[@]}-1; i>=0; i--)); do
        item="${history_items[i]}"
        if [[ -n "$item" ]] && [[ -n "${all_map[$item]}" ]]; then
            echo "$item"
            unset all_map["$item"]
        fi
    done

    # Output remaining non-history items
    for item in "${!all_map[@]}"; do
        echo "$item"
    done
}

# Handle help command
if [[ "$1" == "help" ]] || [[ "$1" == "--help" ]] || [[ "$1" == "-h" ]]; then
    show_help
    exit 0
fi

if [[ $# -eq 1 ]]; then
    selected=$1
else
    # Get configured directories from config file
    config_entries=$(read_config)

    # Get existing tmux sessions (with ● marker)
    declare -A existing_sessions
    sessions=$(tmux ls -F "#{session_name}" 2>/dev/null)
    if [[ -n "$sessions" ]]; then
        while IFS= read -r session; do
            existing_sessions["$session"]=1
        done <<< "$sessions"
    fi

    # Combine: sessions first (marked with ●), then configured entries (session_name (directory))
    # Skip config entries where session already exists
    # Using arrays to avoid subshell overhead
    items=()
    if [[ -n "$sessions" ]]; then
        while IFS= read -r session; do
            items+=("● ${session}")  # Mark tmux sessions with ● and space
        done <<< "$sessions"
    fi
    while IFS=: read -r session_name directory; do
        [[ -z "$session_name" ]] && continue
        # Only show if session doesn't already exist
        if [[ -z "${existing_sessions[$session_name]}" ]]; then
            items+=("${session_name} (${directory})")
        fi
    done <<< "$config_entries"

    # Convert array to newline-separated string
    all_items=$(printf '%s\n' "${items[@]}")

    # Sort items by recency
    sorted_items=$(get_sorted_items "$all_items")

    # Display with fzf (no preview for speed, --no-info skips match count for faster render)
    selected=$(echo "$sorted_items" | fzf --height=100% --layout=reverse --tiebreak=index --no-info | awk 'END {print}')
fi

if [[ -z $selected ]]; then
    exit 0
fi

# Parse selection: format is either "● session_name", "session_name (directory)", or a raw directory/session name
if [[ "$selected" =~ ^●[[:space:]](.+)$ ]]; then
    # Existing tmux session
    session_name="${BASH_REMATCH[1]}"
    update_history "● ${session_name}"
elif [[ "$selected" =~ ^(.+)[[:space:]]\((.+)\)$ ]]; then
    # Configured directory entry: session_name (directory)
    session_name="${BASH_REMATCH[1]}"
    selected_path="${BASH_REMATCH[2]}"

    if [[ ! -d "$selected_path" ]]; then
        echo "Error: Invalid directory path for session $session_name: $selected_path" >&2
        exit 1
    fi

    update_history "$selected"

    # Create session if it doesn't exist
    if ! tmux has-session -t="$session_name" 2> /dev/null; then
        tmux new-session -ds "$session_name" -c "$selected_path"
    fi
else
    # Raw argument: could be a directory path or a session name
    if [[ -d "$selected" ]]; then
        # It's a directory - derive session name from basename
        selected_path="$selected"
        session_name=$(basename "$selected_path" | tr . _)
    else
        # Not a directory - treat as session name, use current directory
        session_name="$selected"
        selected_path="$PWD"
    fi

    # Create session if it doesn't exist
    if ! tmux has-session -t="$session_name" 2> /dev/null; then
        tmux new-session -ds "$session_name" -c "$selected_path"
    fi
fi

# Switch to session
if [[ -z $TMUX ]]; then
    tmux attach -t "$session_name"
else
    tmux switch-client -t "$session_name"
fi
